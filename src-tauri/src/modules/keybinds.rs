use serde::{Deserialize, Serialize};
use std::env;
use std::fs;
use std::path::Path;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Keybind {
    pub id: String,
    pub bind_type: String, // bind, binde, bindm, etc
    pub modifiers: String,
    pub key: String,
    pub dispatcher: String,
    pub args: String,
}

#[derive(Deserialize)]
pub struct SaveKeybindsArgs {
    pub keybinds: Vec<Keybind>,
}

fn get_home_dir() -> String {
    env::var("HOME").unwrap_or_else(|_| "/home/i4104".to_string())
}

#[tauri::command]
pub fn get_keybinds() -> Vec<Keybind> {
    let home = get_home_dir();
    let config_path = Path::new(&home).join(".config/hypr/configs/keybinds.conf");
    let mut keybinds = Vec::new();

    if let Ok(content) = fs::read_to_string(config_path) {
        for (index, line) in content.lines().enumerate() {
            let trim = line.trim();
            if trim.is_empty() || trim.starts_with('#') {
                continue;
            }

            // Try to split at the first '=' to separate type from content
            if let Some((type_part, rest)) = trim.split_once('=') {
                let btype = type_part.trim();

                // Check if it looks like a bind command (bind, binde, bindm, bindl, bindel, bindle, bindr, etc)
                // We assume anything starting with "bind" is a keybind definition
                if btype.starts_with("bind") {
                    let parts: Vec<&str> = rest.splitn(4, ',').collect();
                    if parts.len() >= 3 {
                        let mods = parts[0].trim().to_string();
                        let key = parts[1].trim().to_string();
                        let dispatcher = parts[2].trim().to_string();
                        let args = if parts.len() > 3 {
                            parts[3].trim().to_string()
                        } else {
                            "".to_string()
                        };

                        keybinds.push(Keybind {
                            id: format!("kb-{}", index),
                            bind_type: btype.to_string(),
                            modifiers: mods,
                            key,
                            dispatcher,
                            args,
                        });
                    }
                }
            }
        }
    }
    keybinds
}

#[tauri::command]
pub fn save_keybinds(args: SaveKeybindsArgs) -> Result<(), String> {
    let home = get_home_dir();
    let config_path = Path::new(&home).join(".config/hypr/configs/keybinds.conf");

    // Ensure directory exists
    if let Some(parent) = config_path.parent() {
        let _ = fs::create_dir_all(parent);
    }

    let mut content = String::new();

    content.push_str("# Custom keybinds\n");
    content.push_str("# Auto-generated by Settings\n");

    for kb in args.keybinds {
        // type = MODS, KEY, dispatcher, args
        let btype = if kb.bind_type.is_empty() {
            "bind"
        } else {
            &kb.bind_type
        };
        let mut line = format!(
            "{} = {}, {}, {}",
            btype, kb.modifiers, kb.key, kb.dispatcher
        );
        if !kb.args.is_empty() {
            line.push_str(&format!(", {}", kb.args));
        }
        line.push('\n');
        content.push_str(&line);
    }

    fs::write(config_path, content).map_err(|e| e.to_string())?;

    Ok(())
}
